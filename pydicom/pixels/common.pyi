from _typeshed import Incomplete
from collections.abc import Callable as Callable
from enum import Enum
from pydicom.dataset import Dataset as Dataset
from pydicom.misc import warn_and_log as warn_and_log
from pydicom.pixels.decoders.base import DecodeFunction as DecodeFunction, DecodeOptions as DecodeOptions
from pydicom.pixels.encoders.base import EncodeFunction as EncodeFunction, EncodeOptions as EncodeOptions
from pydicom.pixels.utils import as_pixel_options as as_pixel_options
from pydicom.uid import UID as UID
from typing import Any, TypedDict

Buffer: Incomplete

class CoderBase:
    def __init__(self, uid: UID, decoder: bool) -> None: ...
    def add_plugin(self, label: str, import_path: tuple[str, str]) -> None: ...
    def add_plugins(self, plugins: list[tuple[str, tuple[str, str]]]) -> None: ...
    @property
    def available_plugins(self) -> tuple[str, ...]: ...
    @property
    def is_available(self) -> bool: ...
    @property
    def is_encapsulated(self) -> bool: ...
    @property
    def is_native(self) -> bool: ...
    @property
    def missing_dependencies(self) -> list[str]: ...
    def remove_plugin(self, label: str) -> None: ...
    @property
    def UID(self) -> UID: ...

class PhotometricInterpretation(str, Enum):
    MONOCHROME1: str
    MONOCHROME2: str
    PALETTE_COLOR: str
    RGB: str
    YBR_FULL: str
    YBR_FULL_422: str
    YBR_ICT: str
    YBR_RCT: str
    HSV: str
    ARGB: str
    CMYK: str
    YBR_PARTIAL_422: str
    YBR_PARTIAL_420: str

class RunnerBase:
    def __init__(self, tsyntax: UID) -> None: ...
    @property
    def bits_allocated(self) -> int: ...
    @property
    def bits_stored(self) -> int: ...
    @property
    def columns(self) -> int: ...
    def del_option(self, name: str) -> None: ...
    @property
    def extended_offsets(self) -> tuple[list[int], list[int]] | tuple[bytes, bytes] | None: ...
    def frame_length(self, unit: str = 'bytes') -> int: ...
    def get_option(self, name: str, default: Any = None) -> Any: ...
    @property
    def is_array(self) -> bool: ...
    @property
    def is_binary(self) -> bool: ...
    @property
    def is_buffer(self) -> bool: ...
    @property
    def is_dataset(self) -> bool: ...
    @property
    def number_of_frames(self) -> int: ...
    @property
    def options(self) -> DecodeOptions | EncodeOptions: ...
    @property
    def photometric_interpretation(self) -> str: ...
    @property
    def pixel_keyword(self) -> str: ...
    @property
    def pixel_representation(self) -> int: ...
    @property
    def planar_configuration(self) -> int: ...
    @property
    def rows(self) -> int: ...
    @property
    def samples_per_pixel(self) -> int: ...
    def set_option(self, name: str, value: Any) -> None: ...
    def set_options(self, **kwargs: DecodeOptions | EncodeOptions) -> None: ...
    @property
    def transfer_syntax(self) -> UID: ...
    def validate(self) -> None: ...

class RunnerOptions(TypedDict, total=False):
    bits_allocated: int
    bits_stored: int
    columns: int
    number_of_frames: int
    photometric_interpretation: str
    pixel_keyword: str
    pixel_representation: int
    rows: int
    samples_per_pixel: int
    transfer_syntax_uid: UID
    planar_configuration: int
    extended_offsets: tuple[bytes, bytes] | tuple[list[int], list[int]]
