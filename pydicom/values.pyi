import numpy
import pydicom.uid
import pydicom.valuerep
from _typeshed import Incomplete
from collections.abc import Callable, MutableSequence
from pydicom import config as config
from pydicom.charset import decode_bytes as decode_bytes, default_encoding as default_encoding
from pydicom.config import have_numpy as have_numpy, logger as logger
from pydicom.dataelem import RawDataElement as RawDataElement, empty_value_for_VR as empty_value_for_VR
from pydicom.errors import BytesLengthException as BytesLengthException
from pydicom.filereader import read_sequence as read_sequence
from pydicom.multival import MultiValue as MultiValue
from pydicom.sequence import Sequence as Sequence
from pydicom.tag import BaseTag as BaseTag, Tag as Tag, TupleTag as TupleTag
from pydicom.valuerep import CUSTOMIZABLE_CHARSET_VR as CUSTOMIZABLE_CHARSET_VR, DA as DA, DT as DT, IS as IS, PersonName as PersonName, TEXT_VR_DELIMS as TEXT_VR_DELIMS, TM as TM, validate_value as validate_value
from typing import Any

def multi_string(val: str, valtype: Callable[[str], _T] | None = None) -> _T | MutableSequence[_T]: ...
def convert_tag(byte_string: bytes, is_little_endian: bool, offset: int = 0) -> BaseTag: ...
def convert_AE_string(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> str | MutableSequence[str]: ...
def convert_ATvalue(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> BaseTag | MutableSequence[BaseTag]: ...
def convert_DA_string(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> str | DA | MutableSequence[str] | MutableSequence[DA]: ...
def convert_DS_string(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> pydicom.valuerep.DSclass | MutableSequence[pydicom.valuerep.DSclass] | numpy.float64 | numpy.ndarray: ...
def convert_DT_string(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> str | DT | MutableSequence[str] | MutableSequence[DT]: ...
def convert_IS_string(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> IS | MutableSequence[IS] | numpy.int64 | numpy.ndarray: ...
def convert_numbers(byte_string: bytes, is_little_endian: bool, struct_format: str) -> str | int | float | MutableSequence[int] | MutableSequence[float]: ...
def convert_OBvalue(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> bytes: ...
def convert_OWvalue(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> bytes: ...
def convert_OVvalue(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> bytes: ...
def convert_PN(byte_string: bytes, encodings: list[str] | None = None) -> PersonName | MutableSequence[PersonName]: ...
def convert_string(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> str | MutableSequence[str]: ...
def convert_text(byte_string: bytes, encodings: list[str] | None = None, vr: str | None = None) -> str | MutableSequence[str]: ...
def convert_single_string(byte_string: bytes, encodings: list[str] | None = None, vr: str | None = None) -> str: ...
def convert_SQ(byte_string: bytes, is_implicit_VR: bool, is_little_endian: bool, encoding: list[str] | None = None, offset: int = 0) -> Sequence: ...
def convert_TM_string(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> str | TM | MutableSequence[str] | MutableSequence[TM]: ...
def convert_UI(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> pydicom.uid.UID | MutableSequence[pydicom.uid.UID]: ...
def convert_UN(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> bytes: ...
def convert_UR_string(byte_string: bytes, is_little_endian: bool, struct_format: str | None = None) -> str: ...
def convert_value(VR: str, raw_data_element: RawDataElement, encodings: str | MutableSequence[str] | None = None) -> Any | MutableSequence[Any]: ...

convert_retry_VR_order: Incomplete
converters: Incomplete
