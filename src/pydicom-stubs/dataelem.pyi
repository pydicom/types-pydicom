from _typeshed import Incomplete
from collections.abc import Callable as Callable, MutableSequence
from pydicom import config as config, jsonrep as jsonrep
from pydicom.config import logger as logger
from pydicom.datadict import dictionary_VR as dictionary_VR, dictionary_description as dictionary_description, dictionary_has_tag as dictionary_has_tag, dictionary_is_retired as dictionary_is_retired, dictionary_keyword as dictionary_keyword, private_dictionary_description as private_dictionary_description, repeater_has_tag as repeater_has_tag
from pydicom.dataset import Dataset as Dataset
from pydicom.fileutil import buffer_equality as buffer_equality, buffer_length as buffer_length, check_buffer as check_buffer
from pydicom.hooks import hooks as hooks
from pydicom.jsonrep import BulkDataType as BulkDataType, JsonDataElementConverter as JsonDataElementConverter
from pydicom.misc import warn_and_log as warn_and_log
from pydicom.multival import MultiValue as MultiValue
from pydicom.tag import BaseTag as BaseTag, Tag as Tag
from pydicom.uid import UID as UID
from pydicom.valuerep import ALLOW_BACKSLASH as ALLOW_BACKSLASH, AMBIGUOUS_VR as AMBIGUOUS_VR, BUFFERABLE_VRS as BUFFERABLE_VRS, BYTES_VR as BYTES_VR, DEFAULT_CHARSET_VR as DEFAULT_CHARSET_VR, LONG_VALUE_VR as LONG_VALUE_VR, PersonName as PersonName, STR_VR as STR_VR, validate_value as validate_value
from typing import Any, NamedTuple

def empty_value_for_VR(VR: str | None, raw: bool = False) -> bytes | list[str] | str | None | PersonName: ...

class DataElement:
    descripWidth: int
    maxBytesToDisplay: int
    showVR: bool
    is_raw: bool
    tag: Incomplete
    VR: Incomplete
    validation_mode: Incomplete
    file_tell: Incomplete
    is_undefined_length: Incomplete
    private_creator: Incomplete
    def __init__(self, tag: int | str | tuple[int, int], VR: str, value: Any, file_value_tell: int | None = None, is_undefined_length: bool = False, already_converted: bool = False, validation_mode: int | None = None) -> None: ...
    def validate(self, value: Any) -> None: ...
    @classmethod
    def from_json(cls, dataset_class: type['Dataset'], tag: str, vr: str, value: Any, value_key: str | None, bulk_data_uri_handler: Callable[[str, str, str], BulkDataType] | Callable[[str], BulkDataType] | None = None) -> DataElement: ...
    def to_json_dict(self, bulk_data_element_handler: Callable[[DataElement], str] | None, bulk_data_threshold: int) -> dict[str, Any]: ...
    def to_json(self, bulk_data_threshold: int = 1024, bulk_data_element_handler: Callable[[DataElement], str] | None = None, dump_handler: Callable[[dict[str, Any]], str] | None = None) -> str: ...
    @property
    def value(self) -> Any: ...
    @value.setter
    def value(self, val: Any) -> None: ...
    @property
    def VM(self) -> int: ...
    @property
    def is_buffered(self) -> bool: ...
    @property
    def is_empty(self) -> bool: ...
    @property
    def empty_value(self) -> bytes | list[str] | None | str | PersonName: ...
    def clear(self) -> None: ...
    def __deepcopy__(self, memo: dict[int, Any]) -> DataElement: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    @property
    def repval(self) -> str: ...
    def __getitem__(self, key: int) -> Any: ...
    @property
    def name(self) -> str: ...
    @property
    def is_private(self) -> bool: ...
    @property
    def is_retired(self) -> bool: ...
    @property
    def keyword(self) -> str: ...

class RawDataElement(NamedTuple):
    tag: BaseTag
    VR: str | None
    length: int
    value: bytes | None
    value_tell: int
    is_implicit_VR: bool
    is_little_endian: bool
    is_raw: bool = ...
    is_buffered: bool = ...

def convert_raw_data_element(raw: RawDataElement, *, encoding: str | MutableSequence[str] | None = None, ds: Dataset | None = None) -> DataElement: ...
def __getattr__(name: str) -> Any: ...
