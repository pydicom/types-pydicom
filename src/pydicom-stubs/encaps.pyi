from _typeshed import Incomplete
from collections.abc import Iterator
from io import BufferedIOBase
from pydicom import config as config
from pydicom.filebase import DicomBytesIO as DicomBytesIO, DicomIO as DicomIO, ReadableBuffer as ReadableBuffer
from pydicom.fileutil import buffer_length as buffer_length, reset_buffer_position as reset_buffer_position
from pydicom.misc import warn_and_log as warn_and_log
from pydicom.tag import ItemTag as ItemTag, SequenceDelimiterTag as SequenceDelimiterTag, Tag as Tag
from typing import Any

def parse_basic_offsets(buffer: bytes | bytearray | ReadableBuffer, *, endianness: str = '<') -> list[int]: ...
def parse_fragments(buffer: bytes | bytearray | ReadableBuffer, *, endianness: str = '<') -> tuple[int, list[int]]: ...
def generate_fragments(buffer: bytes | bytearray | ReadableBuffer, *, endianness: str = '<') -> Iterator[bytes]: ...
def generate_fragmented_frames(buffer: bytes | bytearray | ReadableBuffer, *, number_of_frames: int | None = None, extended_offsets: tuple[list[int], list[int]] | tuple[bytes, bytes] | None = None, endianness: str = '<') -> Iterator[tuple[bytes, ...]]: ...
def generate_frames(buffer: bytes | ReadableBuffer, *, number_of_frames: int | None = None, extended_offsets: tuple[list[int], list[int]] | tuple[bytes, bytes] | None = None, endianness: str = '<') -> Iterator[bytes]: ...
def get_frame(buffer: bytes | bytearray | ReadableBuffer, index: int, *, extended_offsets: tuple[list[int], list[int]] | tuple[bytes, bytes] | None = None, number_of_frames: int | None = None, endianness: str = '<') -> bytes: ...

class _BufferedItem:
    buffer: Incomplete
    length: Incomplete
    def __init__(self, buffer: BufferedIOBase) -> None: ...
    def read(self, start: int, size: int) -> bytes: ...

class EncapsulatedBuffer(BufferedIOBase):
    def __init__(self, buffers: list[BufferedIOBase], use_bot: bool = False) -> None: ...
    @property
    def basic_offset_table(self) -> bytes: ...
    @property
    def closed(self) -> bool: ...
    @property
    def extended_lengths(self) -> bytes: ...
    @property
    def extended_offsets(self) -> bytes: ...
    @property
    def encapsulated_length(self) -> int: ...
    @property
    def lengths(self) -> list[int]: ...
    @property
    def offsets(self) -> list[int]: ...
    def read(self, size: int | None = 8192, /) -> bytes: ...
    def readable(self) -> bool: ...
    def seek(self, offset: int, whence: int = ..., /) -> int: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...

def fragment_frame(frame: bytes, nr_fragments: int = 1) -> Iterator[bytes]: ...
def itemize_fragment(fragment: bytes) -> bytes: ...
def itemize_frame(frame: bytes, nr_fragments: int = 1) -> Iterator[bytes]: ...
def encapsulate(frames: list[bytes], fragments_per_frame: int = 1, has_bot: bool = True) -> bytes: ...
def encapsulate_buffer(buffers: list[BufferedIOBase], has_bot: bool = True) -> EncapsulatedBuffer: ...
def encapsulate_extended(frames: list[bytes]) -> tuple[bytes, bytes, bytes]: ...
def encapsulate_extended_buffer(buffers: list[BufferedIOBase]) -> tuple[EncapsulatedBuffer, bytes, bytes]: ...
def __getattr__(name: str) -> Any: ...
