from collections.abc import Callable as Callable
from enum import Enum
from pydicom.dataset import Dataset as Dataset
from pydicom.misc import warn_and_log as warn_and_log
from pydicom.pixels.decoders.base import DecodeFunction as DecodeFunction, DecodeOptions as DecodeOptions
from pydicom.pixels.encoders.base import EncodeFunction as EncodeFunction, EncodeOptions as EncodeOptions
from pydicom.pixels.utils import as_pixel_options as as_pixel_options
from pydicom.uid import UID as UID
from typing import Any, TypedDict

Buffer = bytes | bytearray | memoryview

class CoderBase:
    def __init__(self, uid: UID, decoder: bool) -> None: ...
    def add_plugin(self, label: str, import_path: tuple[str, str]) -> None: ...
    def add_plugins(self, plugins: list[tuple[str, tuple[str, str]]]) -> None: ...
    @property
    def available_plugins(self) -> tuple[str, ...]: ...
    @property
    def is_available(self) -> bool: ...
    @property
    def is_encapsulated(self) -> bool: ...
    @property
    def is_native(self) -> bool: ...
    @property
    def missing_dependencies(self) -> list[str]: ...
    def remove_plugin(self, label: str) -> None: ...
    @property
    def UID(self) -> UID: ...

class PhotometricInterpretation(str, Enum):
    MONOCHROME1 = 'MONOCHROME1'
    MONOCHROME2 = 'MONOCHROME2'
    PALETTE_COLOR = 'PALETTE COLOR'
    RGB = 'RGB'
    YBR_FULL = 'YBR_FULL'
    YBR_FULL_422 = 'YBR_FULL_422'
    YBR_ICT = 'YBR_ICT'
    YBR_RCT = 'YBR_RCT'
    HSV = 'HSV'
    ARGB = 'ARGB'
    CMYK = 'CMYK'
    YBR_PARTIAL_422 = 'YBR_PARTIAL_422'
    YBR_PARTIAL_420 = 'YBR_PARTIAL_420'

class RunnerBase:
    def __init__(self, tsyntax: UID) -> None: ...
    @property
    def bits_allocated(self) -> int: ...
    @property
    def bits_stored(self) -> int: ...
    @property
    def columns(self) -> int: ...
    def del_option(self, name: str) -> None: ...
    @property
    def extended_offsets(self) -> tuple[list[int], list[int]] | tuple[bytes, bytes] | None: ...
    def frame_length(self, unit: str = 'bytes') -> int: ...
    def get_option(self, name: str, default: Any = None) -> Any: ...
    @property
    def is_array(self) -> bool: ...
    @property
    def is_binary(self) -> bool: ...
    @property
    def is_buffer(self) -> bool: ...
    @property
    def is_dataset(self) -> bool: ...
    @property
    def number_of_frames(self) -> int: ...
    @property
    def options(self) -> DecodeOptions | EncodeOptions: ...
    @property
    def photometric_interpretation(self) -> str: ...
    @property
    def pixel_keyword(self) -> str: ...
    @property
    def pixel_representation(self) -> int: ...
    @property
    def planar_configuration(self) -> int: ...
    @property
    def rows(self) -> int: ...
    @property
    def samples_per_pixel(self) -> int: ...
    def set_option(self, name: str, value: Any) -> None: ...
    def set_options(self, **kwargs: DecodeOptions | EncodeOptions) -> None: ...
    @property
    def transfer_syntax(self) -> UID: ...
    def validate(self) -> None: ...

class RunnerOptions(TypedDict, total=False):
    bits_allocated: int
    bits_stored: int
    columns: int
    number_of_frames: int
    photometric_interpretation: str
    pixel_keyword: str
    pixel_representation: int
    rows: int
    samples_per_pixel: int
    transfer_syntax_uid: UID
    planar_configuration: int
    extended_offsets: tuple[bytes, bytes] | tuple[list[int], list[int]]
